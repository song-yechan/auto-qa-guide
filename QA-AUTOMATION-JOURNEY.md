# QA 자동화 고도화 여정

> Claude Code + Playwright 기반 QA 자동화 시스템 구축 과정 기록
> 작성일: 2026-01-22

---

## 목차

1. [프로젝트 개요](#1-프로젝트-개요)
2. [Phase 1: 기본 환경 구축](#2-phase-1-기본-환경-구축)
3. [Phase 2: 프로세스 정립](#3-phase-2-프로세스-정립)
4. [Phase 3: 앱 환경 분리](#4-phase-3-앱-환경-분리)
5. [Phase 4: 실전 테스트 (트래킹 링크 삭제)](#5-phase-4-실전-테스트-트래킹-링크-삭제)
6. [Phase 5: 오케스트레이션 시스템 구축](#6-phase-5-오케스트레이션-시스템-구축)
7. [핵심 교훈 및 인사이트](#7-핵심-교훈-및-인사이트)
8. [현재 상태 및 향후 계획](#8-현재-상태-및-향후-계획)

---

## 1. 프로젝트 개요

### 목표
CS팀 구성원이 Vercel 배포 환경에서 QA 테스트를 자동화할 수 있는 시스템 구축

### 핵심 요구사항
- Claude Code를 처음 사용하는 사람도 쉽게 사용
- 환경 설정 완전 자동화
- 특정 앱 환경 내에서만 테스트 (다른 앱 영향 없음)
- 결과 산출물 자동 정리

### 기술 스택
- **테스트 프레임워크**: Playwright
- **AI 어시스턴트**: Claude Code (Opus 4.5)
- **브라우저**: Chromium (Playwright 내장)
- **세션 관리**: auth.json (쿠키 저장)

---

## 2. Phase 1: 기본 환경 구축

### 문답 과정

**Q (사용자)**: QA 자동화를 하고 싶은데 어떻게 시작해야 해?

**A (Claude)**: Playwright 기반으로 구축하겠습니다. 먼저 환경을 설정하고...

**Q**: 근데 이거 다른 사람이 쓰려면 너무 복잡할 것 같아

**A**: 환경 설정을 완전 자동화하겠습니다. `QA 테스트 요청` 한 마디면 모든 게 자동으로...

### 해결한 문제들

| 문제 | 해결책 |
|------|--------|
| Node.js 설치 필요 | Claude Code 설치 시 자동 포함 |
| Playwright 설치 복잡 | CLAUDE.md에 자동 설치 로직 추가 |
| 브라우저 설치 필요 | `npx playwright install chromium` 자동 실행 |

### 산출물
- `playwright.config.ts`: 기본 설정
- `CLAUDE.md`: Claude 시스템 지침 (Phase 0: 환경 자동 점검)

---

## 3. Phase 2: 프로세스 정립

### 문답 과정

**Q**: 테스트 할 때 전체 내용을 띄우지는 말고, 특정 앱을 요청했을 때 앱 접근까지만 띄워서 확인하고, 나머지는 백그라운드에서 실행해줘

**A**: headed/headless 분리 프로세스를 만들겠습니다.
- Phase 3.5: 앱 접근 확인 (headed, 브라우저 표시)
- Phase 4: 본 테스트 실행 (headless, 백그라운드)

**Q**: 로그인할 때 패스키 팝업 뜨는데 이거 어떻게 해?

**A**: "다른 방법 시도" → "비밀번호" 경로 안내를 가이드에 추가하겠습니다.

**Q**: 세션 저장하고 창 닫으라는 것까지 얘기해야지

**A**: Inspector 창 닫기 안내를 명시적으로 추가했습니다.

### 정립된 워크플로우

```
Phase 1: 정보 수집 (테스트명 → URL → 앱 환경 → 테스트 케이스)
Phase 2: 준비 (폴더 생성, baseURL 설정)
Phase 3: 계획 (테스트 케이스 표 제시, 승인 요청)
Phase 3.5: 앱 접근 확인 (headed 모드, 사용자 확인)
Phase 4: 실행 (headless 모드, 백그라운드)
Phase 5: 산출물 저장
Phase 6: 검증 (HTML 리포트 오픈)
```

### 산출물
- `QA-AUTOMATION-GUIDE.md`: 사용자 가이드
- GitHub 저장소: https://github.com/song-yechan/auto-qa-guide

---

## 4. Phase 3: 앱 환경 분리

### 문답 과정

**Q**: 특수한 앱 환경 내에서만 진행해야 하는 경우가 있어. 다른 앱 안 건드릴 수 있으면 좋겠어.

**A**: 앱 환경 설정 단계를 추가하고, 테스트 코드에서 해당 앱에 정확히 접근했는지 자동 검증하겠습니다.

**Q**: bookscribe인지 아닌지는 어떻게 확인하려고?

**A**: codegen으로 앱 진입 후 확인할 수 있는 셀렉터를 찾겠습니다.

**Q**: 앱 이름 입력할 때 뭘 입력해야 하는지 모르겠어

**A**: "대시보드에 표기된 이름"으로 안내를 명확히 하겠습니다.

### 발견한 셀렉터 패턴

```typescript
// 앱 목록에서 앱 클릭
page.getByRole('link', { name: 'bookscribe' })

// 앱 진입 확인
page.getByRole('button', { name: 'bookscribe bookscribe' })
```

### 구현된 검증 로직

```typescript
async function verifyAppLocation(page: Page, appName: string) {
  const appButton = page.getByRole('button', { name: `${appName} ${appName}` });
  await expect(appButton).toBeVisible({ timeout: 5000 });
}
```

---

## 5. Phase 4: 실전 테스트 (트래킹 링크 삭제)

### 문답 과정

**Q**: 트래킹 링크 삭제 기능 테스트해줘. 테스트 케이스 15개 줄게.

**A**: 분석 결과, 운영 모드에서는 "전체 삭제" 버튼이 없어서 테스트 불가능합니다.

**Q**: 아니 무슨소리야 4-12는 개발모드 아니어도 할 수 있잖아

**A**: (수정) "전체 삭제"(bulk delete)와 개별 삭제는 다른 기능이군요. 개별 삭제는 운영 모드에서도 가능합니다.

### 삭제 버튼 찾기 과정

**1차 시도**: 일반 셀렉터
```typescript
// 실패: 삭제 버튼이 직접 보이지 않음
page.locator('[aria-label*="삭제"]')
```

**Q**: 삭제 버튼 어디 있어?

**A**: codegen으로 확인해주시겠어요?

**Q**: 확인했어. 트래킹 링크를 선택하고 수정버튼까지 눌러야 삭제할 수 있는 버튼이 나와

**A**: 다단계 접근이 필요하군요. 플로우를 수정하겠습니다.

**최종 플로우**:
```
트래킹 링크 관리 → 행 선택 (expand) → 수정 버튼 → 삭제 버튼 → AB180 확인 모달 → 최종 확인 모달
```

### 모달 처리 과정

**문제 1**: 무료 체험 종료 모달
```typescript
// 해결: Escape 키
await page.keyboard.press('Escape');
```

**문제 2**: Ask Airbridge 팝업
```typescript
// 해결: Escape 키 (동일)
await page.keyboard.press('Escape');
```

**문제 3**: AB180 확인 모달 (앱 이름 입력 필요)
```typescript
// 해결: 모달에서 링크 텍스트 추출 후 자동 입력
const linkText = await modal.locator('a').first().textContent();
await confirmInput.type(linkText.trim(), { delay: 50 });
```

**문제 4**: 삭제 버튼이 disabled
```typescript
// 해결: fill() 대신 type() + blur 이벤트
await input.type(value, { delay: 50 });
await modal.locator('text=확인 문구').click(); // blur
```

### 최종 결과
```
✅ 트래킹 링크 삭제 완료 (20.3s)
```

---

## 6. Phase 5: 오케스트레이션 시스템 구축

### 문답 과정

**Q**: 근데 이런 작업을 네가 할 수 없어? 이러면 자동화 하는 이유가 아무것도 없는데

**A**: 맞습니다. 현재 한계:
- 브라우저 화면을 실시간으로 볼 수 없음
- 실패한 테스트 스크린샷만 확인 가능
개선 방안으로 DOM 출력, 탐색적 테스트를 제안합니다.

**Q**: 오케스트레이션 활용해서 구축해봐

**A**: 4개 모듈로 구성된 시스템을 만들겠습니다.

### 구축된 모듈

```
lib/
├── explorer/dom-explorer.ts     # DOM 자동 탐색
├── modal/modal-handler.ts       # 모달 자동 처리
├── data/test-data-manager.ts    # 테스트 데이터 관리
├── flow/flow-recorder.ts        # 플로우 기록
└── utils/test-helpers.ts        # 통합 헬퍼
```

### 검증 결과

```
[ModalHandler] 감지됨: trial-ended
[ModalHandler] 완료: trial-ended
[TestHelper] 앱 접근 성공: bookscribe
[Explorer] 탐색 완료: 55개 요소 발견
✅ 1 passed (14.9s)
```

---

## 7. 핵심 교훈 및 인사이트

### 기술적 교훈

| 분류 | 교훈 | 해결책 |
|------|------|--------|
| 셀렉터 | `getByRole('link')` 실패 시 `getByText()` 시도 | 여러 전략 순차 적용 |
| 입력 | `fill()`이 이벤트 발생 안 함 | `type()` + blur 이벤트 |
| 모달 | 버튼 셀렉터보다 Escape가 범용적 | Escape 우선 사용 |
| 날짜 | 테이블 날짜 클릭 시 date picker 열림 | 고유 셀렉터 사용 |

### 프로세스 교훈

| 분류 | 교훈 |
|------|------|
| 사용자 경험 | 환경 설정은 완전 자동화 필수 |
| 확인 절차 | headed 모드로 사용자 확인 후 headless 실행 |
| 에러 처리 | Inspector 창 닫기 등 명시적 안내 필요 |
| 테스트 분석 | "전체 삭제" vs "개별 삭제" 구분 중요 |

### 자동화 한계 인식

| 가능 | 불가능 |
|------|--------|
| 정해진 플로우 실행 | 새 플로우 자동 발견 |
| 요소 존재 확인 | 실시간 화면 인식 |
| 셀렉터 후보 제안 | 정답 셀렉터 선택 |
| 모달 패턴 처리 | 새 모달 자동 대응 |

---

## 8. 현재 상태 및 향후 계획

### 현재 상태

**자동화 수준: 80%**

| 영역 | 상태 | 비고 |
|------|:----:|------|
| 환경 설정 | ✅ 100% | 완전 자동 |
| 로그인/세션 | ✅ 95% | 패스키 안내만 수동 |
| 앱 접근 | ✅ 100% | 자동 검증 |
| 메뉴 네비게이션 | ✅ 90% | 대부분 자동 |
| 요소 탐색 | ⚠️ 70% | 후보 제안, 선택은 수동 |
| 모달 처리 | ⚠️ 80% | 일부 모달 수동 개입 필요 |
| 다단계 플로우 | ⚠️ 60% | 특이사항 명시 필요 |

### 향후 계획

**단기 (1주)**
- [ ] AB180 모달 핸들러 수정
- [ ] 셀렉터 우선순위 로직 추가

**중기 (1개월)**
- [ ] 사이트맵 기반 네비게이션
- [ ] 테스트 데이터 자동 생성/정리
- [ ] 탐색적 테스트 모드

**장기**
- [ ] 스크린샷 기반 요소 인식 (Vision)
- [ ] 플로우 자동 발견 및 캐싱

---

## 부록: 주요 문답 타임라인

| 단계 | 사용자 질문/피드백 | Claude 대응 |
|------|-------------------|-------------|
| 1 | QA 자동화 시작하고 싶어 | Playwright 기반 설계 |
| 2 | 다른 사람이 쓰기 어려워 보여 | 환경 자동화, 가이드 작성 |
| 3 | 특정 앱에서만 테스트해야 해 | 앱 환경 분리 로직 추가 |
| 4 | 앱 접근 확인하고 나머지는 백그라운드에서 | headed/headless 분리 |
| 5 | 패스키 팝업 어떻게 해? | 우회 경로 가이드 추가 |
| 6 | Inspector 닫으라고 말해야지 | 명시적 안내 추가 |
| 7 | 전체 삭제 vs 개별 삭제 다른 기능이야 | 테스트 케이스 재분석 |
| 8 | 삭제 버튼이 수정 후에 나와 | 다단계 플로우 구현 |
| 9 | 이런 작업 네가 못해? 자동화 의미 없잖아 | 오케스트레이션 시스템 구축 |
| 10 | 프롬프트 템플릿 만들어줘 | 구조화된 요청 양식 작성 |

---

## 결론

이 프로젝트는 단순한 테스트 자동화를 넘어, **사용자 피드백 기반의 점진적 개선** 과정이었습니다.

핵심 성과:
1. **사용성**: "QA 테스트 요청" 한 마디로 시작
2. **안정성**: 앱 격리, 세션 관리, 모달 처리
3. **확장성**: 오케스트레이션 모듈 시스템
4. **문서화**: 가이드, 템플릿, 여정 기록

앞으로도 실제 사용 과정에서 발견되는 문제들을 해결하며 지속적으로 개선해 나갈 예정입니다.
